* 全文
** JVM简述
JVM是Java虚拟机的简称，它是Java语言的跨平台特性实现的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。

** JVM生命周期
JVM的唯一用途就是执行一个Java程序，当一个Java程序启动（main方法），一个JVM实例（在操作系统层面上是一个java进程）就诞生了；当程序关闭退出，这个虚拟机实例也就随之消亡。

** JVM内存结构
JVM运行时包含几块区域：方法区、堆、Java栈、PC寄存器和本地方法栈，其中方法区和堆是线程共享的，而Java栈和PC寄存器则是每个线程独有的。

** 堆和栈的区别
1、堆储存类的实例，栈储存基本类型、引用类型
2、堆是线程共享的，即堆的内容可以被多个线程访问；而栈是独享的，其他线程无法访问。
3、栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

** 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
1、从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
2、堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
3、栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。
4、面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。

** Java中的参数传递时传值呢？还是传引用？
1、不要试图与C进行类比，Java中没有指针的概念。
2、程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。

** Java对象的大小
1、在Java中，一个空Object对象的大小是8byte，这是堆上的大小，加上栈上对象引用的4byte（64位上是8byte），总共是12byte。
2、需要注意的是基本类型的包装类，基本类型是不存在于堆上的，但是包装类型需要堆空间，一个int的包装类Integer占用的空间至少为：对象引用（4） + 空Object（8）=12byte，JVM分配内存以8的整数倍来进行，就是16byte，比单纯使用基本类型大了4倍。因此程序中尽量少使用包装类型。

** Java对象引用类型
对象引用类型分为强引用、软引用、弱引用和虚引用。
1、强引用:就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收
2、软引用:软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。
3、弱引用:弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。
弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何Java对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存
4、虚引用:虚引用get方法永远返回null，它的唯一作用是追踪对象何时被添加到回收队列中，需要和ReferenceQueue引用队列配合使用，虚引用会可以在其引用对象被回收之后自动添加到引用队列中，我们可以知道那些对象将要被回收。

** JVM垃圾回收算法
1、引用计数
2、标记-清除
3、复制
4、标记-整理
5、分代收集
