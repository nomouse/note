* 架构概念

** 组成派
Mary Shaw为“软件架构”给出的定义：软件系统的架构将系统描述为计算组件及组件之间的交互。
计算组件可以进一步细分为处理组件、数据组件和连接组件等。总之，“组件”可以指子系统、框架、模块、类等不同粒度的软件单元，它们可以担负不同的计算职责。

“组成派”软件架构概念有两个显著特点：
关注架构实践中的客体——软件，以软件本身为描述对象
分析了组件的组成，即软件由承担不同计算任务的组件组成，这些组件通过互相交互完成更高层次的计算。

** 决策派
软件架构包含关于以下问题的重要决策：

软件系统的组织
选择组成系统的结构元素和他们之间的接口，以及当这些元素互相协作时所体现的行为
如何组合这些元素，是他们逐渐合成更大的子系统
用于指导这个系统组织的架构风格：这些元素以及他们的接口、协作和组合
软件架构并不仅仅注重软件本身的结构和行为，还要注重其他特性：使用、功能性、性能、弹性、重用、可理解型、经济和技术的限制及权衡，以及美学等。
其核心思想：软件架构是在一些重要方面所作出的决策的集合

“决策派”软件架构概念有两个显著特点：
关注架构实践中的主体——人，以人的决策为描述对象
归纳架构决策的类型，指出架构决策不仅包括关于软件系统的组织、元素、子系统和架构风格等几类决策，还包括众多非功能需求的决策

** 分类
将软件架构概念分类的好处是：包容细节差异、明确本质共性、促成概念总体上的清晰。下面列举几个著名的软件架构定义，以期达到下列目的：
体会和证明众多软件架构概念都是围绕“组成”和“决策”两个视角展开的；
开阔视野，说不定和你合作的同事所接受的软件架构概念就是其中的一种。

架构概念的“决策派”
Booch、Rumbaugh和Jacobson的定义：架构是一系列重要决策的集合，这些决策与以下内容有关：软件的组织，构成系统的结构元素及其接口的选择，
这些元素在相互协作中明确表现出的行为，这些结构元素和行为元素进一步组合所构成的更大规模的子系统，以及指导这一组织——包括这些元素及其接口、
它们的协作和它们的组合——架构风格。
Woods的观点：Eoin Woods是这样认为的：软件架构是一系列设计决策，如果作了不正确的决策，你的项目可能最终会被取消。

架构概念的“组成派”
Garlan和Shaw的定义：Garlan和Shaw认为：架构包括组件（Component）、连接件（Connector）和约束（Constrain）三大要素。组件可以是一组代码（例如程序模块），也可以是独立的程序（例如数据库服务器）。连接件可以是过程调用、管道和消息等，用于表示组件之间的相互关系。“约束”一般为组件连接时的条件。
Perry和Wolf的定义：Perry和Wolf提出：软件架构是一组具有特定形式的架构元素，这些元素分为三类：负责完成数据加工的处理元素（Processing Elements）、作为被加工信息的数据元素（Data Elements）及用于把架构的不同部分组合在一起的连接元素（Connecting Elements）。
Boehm的定义：Barry Boehm和他的学生提出：软件架构包括系统组件、连接件和约束的集合，反应不同涉众需求的集合，以及原理（Rationale）的集合。其中的原理，用于说明由组件、连接件和约束所定义的系统在实现时，是如何满足不同涉众需求的。
IEEE的定义：IEEE 610.12-1990软件工程标准词汇中是这样定义架构的：架构是以组件、组件之间的关系、组件与环境之间的关系为内容的某一系统的基本组织结构，以及指导上述内容设计与演化的原理（Principle）。
Bass的定义：SEI（Software Engineering Institute, SEI，美国卡内基梅隆大学软件研究所）的Bass等人给架构的定义是：某个软件或计算机系统的软件架构是该系统的一个或多个结构，每个结构均由软件元素、这些元素的外部可见属性、这些元素之间的关系组成。


* 架构定义
** 软件架构:软件系统的顶层结构
这个定义看似很简单，但包含的信息很丰富，基本上把系统、子系统、模块、组件、架构等概念都串起来了，我来详细解释一下。
首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。
其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。
第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。

*** 概述
对于技术人员来说，“架构”是一个再常见不过的词了。我们会对新员工培训整个系统的架构，参加架构设计评审，学习业界开源系统
（例如，MySQL、Hadoop）的架构，研究大公司的架构实现（例如，微信架构、淘宝架构）……虽然“架构”这个词常见
，但如果深究一下“架构”到底指什么，大部分人也许并不一定能够准确地回答。
例如：
架构和框架是什么关系？有什么区别？
Linux有架构，MySQL有架构，JVM也有架构，使用Java开发、MySQL存储、跑在Linux上的业务系统也有架构，应该关注哪个架构呢？
微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当我们谈微信架构时，到底是在谈什么架构？
要想准确地回答这几个问题，关键在于梳理几个有关系而又相似的概念，包括：系统与子系统、模块与组件、框架与架构。

*** 系统和子系统
我们先来看维基百科定义的“系统”。

系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。
我来提炼一下里面的关键内容：
关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台PC放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。
规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。
能力：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。

子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。

其实子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。
按照这个定义，系统和子系统比较容易理解。我们以微信为例来做一个分析。
微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。
朋友圈这个系统又包括动态、评论、点赞等子系统。
评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。
评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。例如，MySQL、Redis等是存储系统，但不是业务子系统。

*** 模块和组件
模块和组件两个概念在实际工作中很容易混淆，我们经常能够听到类似这样的说法：

MySQL模块主要负责存储数据，而ElasticSearch模块主要负责数据搜索。
我们有安全加密组件、有审核组件。
App的下载模块使用了第三方的组件。
造成这种现象的主要原因是，模块与组件的定义并不好理解，也不能很好地进行区分。我们来看看这两者在维基百科上的定义。

软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。
模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。

软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。

可能你看完这两个定义后一头雾水，还是不知道这两者有什么区别。造成这种现象的根本原因是，模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。
从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；
划分组件的主要目的是单元复用。其实，“组件”的英文component也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。

我以一个最简单的网站系统来为例。
假设我们要做一个学生信息管理系统，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”“个人成绩模块”；
从物理的角度来拆分，可以拆分为Nginx、Web服务器、MySQL。
从开发规范角度来拆分，可以用MVC架构实现。
这些“架构”，都是“学生管理系统”正确的架构，只是从不同的角度来分解而已，这也是IBM的RUP将软件架构视图分为著名的“4+1视图”的原因。

*** 框架
框架是和架构比较相似的概念，且两者有较强的关联关系，所以在实际工作中，这两个概念有时我们容易分不清楚。参考维基百科上框架与架构的定义，我来解释两者的区别。

软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。

我来提炼一下其中关键部分：

框架是组件规范：例如，MVC就是一种最常见的开发规范，类似的还有MVP、MVVM、J2EE等框架。
框架提供基础功能的产品：例如，Spring MVC是MVC的开发框架，除了满足MVC的规范，Spring提供了很多基础功能来帮助我们实现功能，
包括注解（@Controller等）、Spring Security、Spring JPA等很多基础功能。
软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。

单纯从定义的角度来看，框架和架构的区别还是比较明显的，框架关注的是“规范”，架构关注的是“结构”。框架的英文是Framework，
架构的英文是Architecture。Spring MVC的英文文档标题就是“Web MVC framework”。

虽然如此，在实际工作中我们却经常碰到一些似是而非的说法。
例如，“我们的系统是MVC架构”“我们需要将android app重构为MVP架构”“我们的系统基于SSH框架开发”“我们是SSH的架构”“XX系统是基于Spring MVC框架开发，标准的MVC架构”……

究竟什么说法是对的，什么说法是错的呢？
其实这些说法都是对的，造成这种现象的根本原因隐藏于架构的定义中，关键就是“基础结构”这个概念并没有明确说是从什么角度来分解的。
采用不同的角度或者维度，可以将系统划分为不同的结构，其实我在“模块与组件”中的“学生管理系统”示例已经包含了这点。


** 软件架构:对系统设计的可共享的理解。
首先，架构是最高层次的系统分解
其次，架构需要规定系统中不易改变的决定


** 软件架构:通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。
*** 序
物理学中有个很著名的“熵增定律”：一个封闭系统，都是从有序到无序，也就是它的熵（即混乱程度）会不断地增加，最终系统会彻底变得无序。

这个理论放在软件系统的演化上，也是非常适用的。

一方面，随着业务需求的增加，我们会往系统里不停地添加业务功能；另一方面，随着访问量的不断增加，我们会不断通过技术手段来加强系统非业务性功能。如果事先不做良好的设计，随着时间的推进，整个系统野蛮生长，就会逐渐碎片化，越来越无序，最终被推倒重来。
不过，自然界中的生物可以通过和外界交互，主动进行新陈代谢，制造“负熵”，也就是降低混乱程度，来保证自身的有序性，继续生存。比如，植物通过光合作用，把光能、二氧化碳和水合成有机物，以此滋养自己，延续生命。对于软件系统，我们也可以主动地调整系统各个部分的关系，保证系统整体的有序性，来更好地适应不断增长的业务和技术变化。这种系统内部关系的调整就是通过架构实现的，所以，架构的本质就是：

通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。

这里包含两层意思，我们具体展开说下：

*** 首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。
我们知道架构这个词来源于建筑行业，那为什么建筑行业需要“架构”呢？

搭一个草房子很简单，可以直接上手；盖一个2层楼房，稍微复杂一些，但在工匠的经验指导下，问题也不大；而盖一座高楼，复杂性就大不一样了，我们需要考虑内部结构、承重、采光、排水、防雷抗震等，这就需要专业人员事先做好整体的架构设计，并严格地按照设计来施工。

这里，你可以看到，建筑里的架构不是天然就有的，而是因为建筑越来越复杂，我们需要通过架构来管理这种复杂性，避免建造过程的失控。

软件系统也是如此，从简单的桌面应用发展到现在的大型互联网平台，这个过程中，系统规模越来越大，业务和技术也越来越复杂。我们同样需要通过架构设计，消化复杂性带来的混乱，使系统始终处于一个有序状态，能够应对现有和将来的需求变化。

*** 其次，架构实现从无序到有序，是通过合理的内部编排实现的。
基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。

物理学中有个很著名的“熵增定律”：一个封闭系统，都是从有序到无序，也就是它的熵（即混乱程度）会不断地增加，最终系统会彻底变得无序。

这个理论放在软件系统的演化上，也是非常适用的。

一方面，随着业务需求的增加，我们会往系统里不停地添加业务功能；另一方面，随着访问量的不断增加，我们会不断通过技术手段来加强系统非业务性功能。如果事先不做良好的设计，随着时间的推进，整个系统野蛮生长，就会逐渐碎片化，越来越无序，最终被推倒重来。

不过，自然界中的生物可以通过和外界交互，主动进行新陈代谢，制造“负熵”，也就是降低混乱程度，来保证自身的有序性，继续生存。比如，植物通过光合作用，把光能、二氧化碳和水合成有机物，以此滋养自己，延续生命。对于软件系统，我们也可以主动地调整系统各个部分的关系，保证系统整体的有序性，来更好地适应不断增长的业务和技术变化。这种系统内部关系的调整就是通过架构实现的，所以，架构的本质就是：

通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。

这里包含两层意思，我们具体展开说下：

首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。我们知道架构这个词来源于建筑行业，那为什么建筑行业需要“架构”呢？

搭一个草房子很简单，可以直接上手；盖一个2层楼房，稍微复杂一些，但在工匠的经验指导下，问题也不大；而盖一座高楼，复杂性就大不一样了，我们需要考虑内部结构、承重、采光、排水、防雷抗震等，这就需要专业人员事先做好整体的架构设计，并严格地按照设计来施工。

这里，你可以看到，建筑里的架构不是天然就有的，而是因为建筑越来越复杂，我们需要通过架构来管理这种复杂性，避免建造过程的失控。

软件系统也是如此，从简单的桌面应用发展到现在的大型互联网平台，这个过程中，系统规模越来越大，业务和技术也越来越复杂。我们同样需要通过架构设计，消化复杂性带来的混乱，使系统始终处于一个有序状态，能够应对现有和将来的需求变化。

其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。

* 架构分类

没有统一的标准
有按实现层次划分的、有按关注方向划分的、有按软工阶段划分的、有按视图类型划分的、有按技术实现风格划分的……等等。

就是从不同的角度、不同的侧重点，对架构设计这件事进行划分，当然有很多是交叉重叠的。

** 按实现层次划分
移动架构

前端架构

系统架构（应用架构，技术架构）

平台架构

应用集成架构

数据库架构

存储架构

网络架构

……

** 按关注方向划分
业务架构

应用架构

技术架构

开发架构

数据库架构

存储架构

安全架构

部署架构

开放架构（OpenAPI架构）

……

** 按软工阶段划分
解决方案架构

业务架构

系统架构

概念架构

细化架构

平台架构

开发架构

部署架构

运维架构

……

** 按视图类型划分
逻辑架构

数据架构

开发架构

运行架构

物理架构

……

** 按技术实现风格划分
分布式架构

微服务架构

分层架构

事件驱动架构

微内核架构

SOA架构

响应式架构


